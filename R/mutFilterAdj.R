#' mutFilterAdj
#' @description Filter SNVs with adjacent indels
#'
#' @param maf An MAF data frame, generated by \code{\link{vcfToMAF}} function.
#' @param maxIndelLen Maximum length of indel accepted to be included.
#' Default: 50
#' @param minInterval Minimum length of interval between an SNV and an indel
#' accepted to be included. Default: 10
#'
#' @return An MAF data frame after filtration for adjacent variants.
#'
#' @import dplyr
#'
#' @export mutFilterAdj
#' @examples
#' maf <- vcfToMAF(system.file("extdata",
#' "WES_EA_T_1_mutect2.vep.vcf",package = "CaMutQC"))
#' mafF <- mutFilterAdj(maf)


mutFilterAdj <- function(maf, maxIndelLen = 50, minInterval = 10){
    if ("DEL" %in% unique(maf$Variant_Type) | 
        "INS" %in% unique(maf$Variant_Type)) {
        # create an indel bed with indels of length <= maxIndelLen
        bed_frame <- selectIndel(maf, maxIndelLen, minInterval)
        snp_frame <- maf[which(maf$Variant_Type == "SNP"), ]
        # add tags to variants in expanded bed
        n_tags <- rownames(snp_frame[snp_frame$Chromosome 
                                     %in% bed_frame$Chromosome 
                                     & snp_frame$Start_Position 
                                     %in% bed_frame$Location,])
        maf[n_tags, 'CaTag'] <- paste0(maf[n_tags, 'CaTag'] , 'A')
    }
    # else: directly return maf if there is no INDEL in maf data frame
    return(maf)
}

# select indel with length <= maxIndelLen, and return the corresponding bed
selectIndel <- function(mafDat, maxIndelLen = 50, minInterval = 10) {
    indels <- rownames(mafDat[(mafDat$Variant_Type %in% c("DEL", "INS")) & 
                              (mafDat$End_Position - mafDat$Start_Position <=
                                 maxIndelLen),])
    chrs <- mafDat[indels, "Chromosome"]
    starts <- mafDat[indels, "Start_Position"]
    ends <- mafDat[indels, "End_Position"]
    tmpbed <- data.frame(Chromosome = chrs, 
                         Start_Position = starts - minInterval, 
                         End_Position = ends + minInterval)
    # generate the bed framn first
    finalbed <- data.frame(matrix(ncol=2))
    colnames(finalbed) <- c("Chromosome", "Location")
    # iterate through every row of bed file, split it into single base
    for (i in seq_len(nrow(tmpbed))) {
      nbase <- length(tmpbed[i,2]:tmpbed[i,3])
      currentbed <- data.frame(rep(tmpbed[i, 1]), tmpbed[i,2]:tmpbed[i,3])
      colnames(currentbed) <- c("Chromosome", "Location")
      finalbed <- rbind(finalbed, currentbed)
    }
    # remove duplicated rows
    finalbed <- na.omit(finalbed[!duplicated(finalbed),])
    rownames(finalbed) <- seq_len(nrow(finalbed))
    return(finalbed)
}
