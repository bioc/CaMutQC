#' fpfilter
#' @description R version of fpfilter tool from USCScancer, 
#' for somatic mutation filtration.
#'
#' @param maf An MAF data frame, generated by \code{\link{vcfToMAF}} function.
#' @param bamcount_tumor Bam-readcount output file of tumor sample 
#' after running bam-readcount pipeline.
#' @param keep Logical. Whether to keep the variants with no matches found
#' in bam-readcount file. Default: TRUE
#' @param minReadPos Minimum threshold of read position. Default: 0.1
#' @param VAF Threshold of VAF value. Default: 0.05
#' @param varCount Threshold of variant count (allele depth). Default: 4
#' @param minStrand Minimum threshold of strand-specific parameter. Default: 0.01
#' @param maxStrand Maximum threshold of strand-specific parameter. Default: 0.99
#' @param maxQualsumDiff Maximum threshold of mismatch quality sum, 
#' where variant allele mismatch-quality-sum is significantly higher 
#' than reference allele mmqs. Default: 50
#' @param maxMapqualDiff Maximum threshold of mapping quality difference.
#' Default: 30
#' @param maxReadlenDiff Maximum threshold of read length difference.
#' Default: 25
#' @param minVarDist Minimum threshold of variant distance difference. 
#' Default: 0.20
#' @param maxVarQualsum Maximum threshold of variant mapping quality.
#' Default: 100
#' 
#' @return An MAF data frame after fpfilter
#' @import stringr
#' @export fpfilter


fpfilter <- function(maf, bamcount_tumor = NULL, keep = TRUE, minReadPos = 0.1,
                     VAF = 0.05, varCount = 4, minStrand = 0.01, 
                     maxStrand = 0.99, maxQualsumDiff = 50, 
                     maxMapqualDiff  = 30, maxReadlenDiff = 25, 
                     minVarDist = 0.20, maxVarQualsum = 100) {
  
  # VAF and read count filtration
  maf_filter <- mutFilterQual(maf, VAF = VAF, tumorAD = varCount, 
                              VAFratio = 0, tumorDP = 0, normalDP = 0)
  if (is.null(bamcount_tumor)) {
    warning("Only VAF filtration and read count filtration will be proceeded 
    because bam-readcount file is missing.")
    
  }else{
    # read and sort bam-count file
    maxColTumor <- max(count.fields(bamcount_tumor, sep = '\t'))
    
    bcTumor <- read.table(bamcount_tumor, header = FALSE, sep = "\t", 
                           col.names = paste0("V", seq_len(maxColTumor)), 
                           fill = TRUE)
    colnames(bcTumor)[1:4] <- c('chr', 'position', 'reference_base', 'depth')
    bcTumor$reference_base <- toupper(bcTumor$reference_base)
    
    # traverse every line in maf_filter for potential filtration
    discard <- c()
    for (i in 1:nrow(maf_filter)){
       bcMatch <- bcTumor[which(bcTumor$chr == maf_filter$Chromosome[i] & 
                                  bcTumor$position == maf_filter$Start_Position[i] & 
                                  bcTumor$reference_base == 
                                  maf_filter$Reference_Allele[i]), ]
       if (nrow(bcMatch) == 0) {
         if (!(keep)) {
           discard <- c(discard, i)
         }
       }else {
         if (nrow(bcMatch) == 1) {
           bcInfo <- parseVar(bcMatch)
           rownames(bcInfo) <- c('1', '2')
         }else{
           bcInfo <- parseVar(bcMatch[1, ])
           for (j in 2:nrow(bcMatch)) {
             bcInfo <- rbind(bcInfo, parseVar(bcMatch[j, ])[2, ])
           }
           rownames(bcInfo) <- c('1', rownames(bcMatch))
         }
         
         # filter process
         filterDes <- filterVar(maf_filter$Tumor_Seq_Allele2[i], bcInfo, 
                                keep = keep, minReadPos = minReadPos, 
                                minStrand = minStrand, maxStrand = maxStrand, 
                                maxQualsumDiff = maxQualsumDiff, 
                                maxReadlenDiff = maxReadlenDiff,
                                maxMapqualDiff  = maxMapqualDiff, 
                                minVarDist = minVarDist, 
                                maxVarQualsum = maxVarQualsum)
         if(!(filterDes)){
           discard <- c(discard, i)
         }
       }
    }
    
    if (!(is.null(discard))){
      maf_filter <- maf[-discard, ]
    }
  }
  return(maf_filter)
  
}

parseVar <- function(bcLine) {
  charAll <- str_split_fixed(bcLine[1, 5:14], pattern = ":", n = 3)
  Var <- charAll[which(!charAll[, 2] %in% c('0', '')), ]
  if (is.null(dim(Var))){
    return('No variants')
  } else if (nrow(Var) >= 3) {
    Var <- Var[which(order(as.numeric(Var[, 2])) > nrow(Var) - 2), ]
  }
  
  # parse out parameters froom bam-readcount data
  ## num_reads, avg_mapqual, avg_basequal, avg_semq, reads_plus, reads_minus,
  ## avg_clip_read_pos, avg_mmqs_reads_q2, avg_dist_to_q2, avgRLclipped, 
  ## avg_eff_3'_dist
  varDat <- data.frame(matrix(nrow = 2, ncol = 14))
  colnames(varDat) <- c('base', 'count', 'map_qual', 'base_qual', 'semq', 
                        'plus', 'minus', 'pos', 'subs', 'mmqs', 'q2_reads', 
                        'q2_dist', 'avg_rl', 'dist_3')

  varDat$base <- Var[, 1]
  varDat$count <- as.numeric(Var[, 2])
  varDat[1, 3:14] <- as.numeric(str_split(Var[, 3], pattern = ":")[[1]])
  varDat[2, 3:14] <- as.numeric(str_split(Var[, 3], pattern = ":")[[2]])
  
  # order lines in varDat to make sure ref allele is in the first line
  varDat <- varDat[order(varDat$count, decreasing = TRUE), ]
  
  # check consistence of ref allele and base info
  varDat$base <- toupper(varDat$base)
  if (varDat[1, 1] != bcLine$reference_base){
    stop(paste0('Inconsistence found in bam-count file in line ', 
                rownames(bcLine), '.'))
  }
  
  return(varDat)
}


filterVar <- function(mafVar, bcDat, keep = TRUE, minReadPos = 0.1,
                      minStrand = 0.01, maxStrand = 0.99, 
                      maxQualsumDiff = 50, maxMapqualDiff  = 30, 
                      maxReadlenDiff = 25, minVarDist = 0.20, 
                      maxVarQualsum = 100) {
  
  # process inconsistent representation of maf and bam-count file
  if (substr(mafVar, 1, 1) == '-'){
    mafVar <- substr(mafVar, 1, nchar(mafVar))
  }
  # check for Tumor_Seq_Allele2
  if (!(mafVar %in% bcDat$base)) {
    return(keep)
  }else{
    if (sum(bcDat$base == mafVar) >= 2){
      #return(bcDat)
      stop('Mutiple lines have similar information: ', 
           paste0('line', rownames(bcDat)[2:nrow(bcDat)]))
    }else{
      bcDat <- rbind(bcDat[1, ], bcDat[which(bcDat$base == mafVar), ])
      if(nrow(bcDat) > 2) {
        warning('bcdat has more than 2 lines, check filtervar function.')
      }
      
      # filters
      # determine parameters
      ref_strandedness <- 0.50
      var_strandedness <- 0.50
      if (is.na(bcDat$dist_3[1])) {
        bcDat$dist_3[1] <- 0.5
      }
      
      ## Use conservative defaults if we can't get mismatch quality sums ##
      if(is.na(bcDat$mmqs[1])){
        bcDat$mmqs[1] <- 50
      }
      
      if(is.na(bcDat$mmqs[2])){
        bcDat$mmqs[2] <- 0
      }
      
      mismatch_qualsum_diff <- bcDat$mmqs[2] - bcDat$mmqs[1]
      
      ## Determine map qual diff 
      
      mapqual_diff <- bcDat$map_qual[1] - bcDat$map_qual[2]
      
      ## Determine difference in average supporting read length 
      
      readlen_diff <- bcDat$avg_rl[1] - bcDat$avg_rl[2]
      
      ## Determine ref strandedness 
      
      if((bcDat$plus[1] + bcDat$minus[1]) > 0) {
        ref_strandedness <- round(bcDat$plus[1] / 
                                    (bcDat$plus[1] + bcDat$minus[1]), 2)
      }
      
      ## Determine var strandedness 
      
      if((bcDat$plus[2] + bcDat$minus[2]) > 0) {
        var_strandedness <- round(bcDat$plus[2] / 
                                    (bcDat$plus[2] + bcDat$minus[2]), 2)
      }
      
      if(bcDat$count[2] && (bcDat$plus[2] + bcDat$minus[2])) {
        ## We must obtain variant read counts to proceed ##
        
        var_freq <- bcDat$count[2] / (bcDat$count[2] + bcDat$count[1])
        
        ## FAILURE 1: READ POSITION ##
        if(bcDat$pos[2] < minReadPos) {
          return(FALSE)
        }
        
        ## FAILURE 2: Variant is strand-specific but reference is NOT strand-specific 
        if((var_strandedness < minStrand || var_strandedness > maxStrand) && 
           (ref_strandedness >= minStrand && ref_strandedness <= maxStrand)) {
          return(FALSE)
        }
        
        ## FAILURE : Variant allele count does not meet minimum ##
        #if(bcDat$count[2] < $min_var_count) {
        #$stats{'num_fail_varcount'}++;
        #return(FALSE)
        #}
        
        ## FAILURE : Variant allele frequency does not meet minimum ##
        #if($var_freq < $min_var_freq) {
        #$stats{'num_fail_varfreq'}++;
        #return()
        #}
        
        ## FAILURE 3: Paralog filter for sites where variant allele 
        # mismatch-quality-sum is significantly higher than reference allele mmqs
        if(mismatch_qualsum_diff > maxQualsumDiff) {
          #$stats{'num_fail_mmqs'}++;
          return(FALSE)
        }
        
        ## FAILURE 4: Mapping quality difference exceeds allowable maximum 
        if(mapqual_diff > maxMapqualDiff) {
          #$stats{'num_fail_mapqual'}++;
          return(FALSE)
        }
        
        ## FAILURE 5: Read length difference exceeds allowable maximum ##
        if(readlen_diff > maxReadlenDiff) {
          #$stats{'num_fail_readlen'}++;
          return(FALSE)
        }
        
        ## FAILURE 6: Read distance lower than allowable minimum 
        if(bcDat$dist_3[2] < minVarDist) {
          #$stats{'num_fail_dist3'}++;
          return(FALSE)
        }
        
        if(maxVarQualsum && bcDat$mmqs[2] > maxVarQualsum) {
          #$stats{'num_fail_var_mmqs'}++;
          return(FALSE)
        }
        
        ## SUCCESS: Pass Filter ##
        return(TRUE)
        
      } else {
        stop('No variant count information found.')
      }
      
    }
  }
}


