#' mutFilterSB
#' @description Filter variants based on strand bias.
#'
#' @param maf An MAF object, generated by \code{\link{vcfToMAF}} function.
#' @param tumorSampleName Label of the tumor sample, should be one of the
#' column names of maf. If it is set as 'Extracted', tumorSampleName would be
#' extracted automatically from the maf data frame. Default: 'Extracted'.
#' @param method Method will be used to detect strand bias,
#' including 'SOR' and 'Fisher'. Default: 'SOR'. SOR: StrandOddsRatio
#' (https://gatk.broadinstitute.org/hc/en-us/articles/360041849111-
#' StrandOddsRatio) Fisher's Exat Test: Switch to Phred socre
#' (https://gatk.broadinstitute.org/hc/en-us/articles/360035532152-Fisher-
#' s-Exact-Test)
#' @param SBscore Cutoff strand bias score used to filter variants.
#' Default: 3
#'
#' @return An MAF data frame where some variants
#' has S tag in CaTag column for strand bias filtration
#'
#' @export mutFilterSB
#' @examples
#' maf <- vcfToMAF(system.file("extdata", "GC48-2_mutect2.vep.vcf",
#' package = "CaMutQC"))
#' mafF <- mutFilterSB(maf)

mutFilterSB <- function(maf, tumorSampleName = 'Extracted',
                        method = 'SOR', SBscore = 3) {

  ## get tumorSampleName and normalSampleName
  if (tumorSampleName == 'Extracted'){
    tumorSampleName <- unique(maf$Tumor_Sample_Barcode)
  } else if(!(tumorSampleName %in% colnames(maf))) {
    stop('Invaild tumorSampleName.')
  }

  # use for loop to get the SB score for each variation
  if (method == 'Fisher') {
    for (i in seq_len(nrow(maf))) {
      SBindex <- strsplit(maf$FORMAT[i], ':')[[1]] == 'SB'
      if (all(SBindex == FALSE)){
        F1R2index <- strsplit(maf$FORMAT[i], ':')[[1]] == 'F1R2'
        F2R1index <- strsplit(maf$FORMAT[i], ':')[[1]] == 'F2R1'
        F1R2 <- strsplit(maf[i, tumorSampleName], ':')[[1]][F1R2index]
        F2R1 <- strsplit(maf[i, tumorSampleName], ':')[[1]][F2R1index]
        rf <- strsplit(F1R2, ',')[[1]][1]
        af <- strsplit(F1R2, ',')[[1]][2]
        rv <- strsplit(F2R1, ',')[[1]][1]
        av <- strsplit(F2R1, ',')[[1]][2]
        SBcharmatix <- paste(rf, rv, af, av, sep = ',')
        # print(SBcharmatix)
      }else{
        SBcharmatix <- strsplit(maf[i, tumorSampleName],
                                ':')[[1]][SBindex]
      }
      if (calSBscore(SBcharmatix, method) > SBscore) {
        maf[i, 'CaTag'] <- paste0(maf[i, 'CaTag'] , 'S')
      }
    }
  }else if (method == 'SOR'){
    for (i in seq_len(nrow(maf))) {
      F1R2index <- strsplit(maf$FORMAT[i], ':')[[1]] == 'F1R2'
      F2R1index <- strsplit(maf$FORMAT[i], ':')[[1]] == 'F2R1'
      F1R2 <- strsplit(maf[i, tumorSampleName], ':')[[1]][F1R2index]
      F2R1 <- strsplit(maf[i, tumorSampleName], ':')[[1]][F2R1index]
      SBcharmatix <- paste(F1R2, F2R1, sep = ',')
      if (calSBscore(SBcharmatix, method) > SBscore) {
        maf[i, 'CaTag'] <- paste0(maf[i, 'CaTag'] , 'S')
      }
    }
  }
    # maf[discard, 'CaTag'] <- paste0(maf[discard, 'CaTag'] , 'S')
    return(maf)
}

## construct function to calculate the SB score for strand bias detection
calSBscore <- function(charmatrix, method = 'SOR'){
  depths <- as.numeric(strsplit(charmatrix, ",")[[1]])
  if (method == 'SOR') {
    refFw <- depths[1] + 1
    refRv <- depths[3] + 1
    altFw <- depths[2] + 1
    altRv <- depths[4] + 1
    symmetricalRatio <- (refFw * altRv)/(refRv * altFw) +
      (refRv * altFw) / (refFw * altRv)

    refRatio <- min(refRv, refFw) / max(refRv, refFw)
    altRatio <- min(altRv, altFw) / max(altRv, altFw)
    score <- log(symmetricalRatio) + log(refRatio) - log(altRatio)

  }else if (method == 'Fisher')   {
    refFw <- depths[1]
    refRv <- depths[2]
    altFw <- depths[3]
    altRv <- depths[4]
    Row1 <- refRv + refFw
    Row2 <- altRv + altFw
    Col1 <- refFw + altFw
    Col2 <- refRv + altRv

    P1 <- calP(refFw, refRv, altFw, altRv)

    # check P1 whether it is over the depth
    if (is.na(P1)){
      stop(paste0('Your data is in high coverage that ',
                  'the factorial of its depth can not be obtained, ',
                  'please use \'SOR\' method instead.'))
    }

    # probability of observing more extreme data
    vaildP <- c()

    # get the range of refFw
    maxR <- min(Row1, Col1)
    minR <- max(0, Row1-Col2)
    for (i in minR:maxR){
      exP <- calP(i, Row1-i, Col1-i, Col2 - Row1 + i)
      if(exP <= P1){
        vaildP <- c(vaildP, exP)
      }
    }

    # get sum of P
    Pt <- sum(P1, vaildP)

    # get Phred score
    score <- -10 * log10(Pt)
  }else {
    stop('Please select a method from SOR and Fisher')
  }
  return(score)
}


calP <- function(refFw, refRv, altFw, altRv){
  R1 <- refRv + refFw
  R2 <- altRv + altFw
  C1 <- refFw + altFw
  C2 <- refRv + altRv

  # probability P
  P <- (factorial(R1) * factorial(R2) * factorial(C1) * factorial(C2))/
    (factorial(R1 + R2) * factorial(refRv) * factorial(refFw) *
       factorial(altFw) * factorial(altRv))
  return(P)
}

